Spring Boot @SpringBootApplication Annotation

it is used to mark a configuration class that declares one or more @Bean methods and also triggers auto-configuration and component scanning. 

it is equal to a class that is annoted with @componentscan , @Configuration and @Enableautoconfiguration.
__________________________________________________________________________________________________________________________________________________________________________

@SpringBootApplication
public class SpringBootRestApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringBootRestApplication.class, args);
	}
}

explain this code ?

-> The SpringBootApplication is a meta annotation that combines several annotation into one. It is commonly used to annotate the main class of a spring boot application.
-> The main method is the starting point of application. it calls the run method of spring application class 
-> the run method starts the application and performs various intialisation tasks like it sets up spring application context, loads, configurers beans and startsthe     
   emebeded tomcat server.
-> by running this class it starts the spring boot applocation that listens the incomming http requests and handles them using restful principles.
_______________________________________________________________________________________________________________________________________________________________________

Hibernate Framework:

Hibernate is a Java framework that simplifies the development of Java application to interact with the database. It is an open source, lightweight, ORM (Object Relational Mapping) tool. Hibernate implements the specifications of JPA (Java Persistence API) for data persistence.

-> Hybernet is one of the best ORM framework availabe for java.
_________________________________________________________________________________________________________________________________________________________________________

What is Spring Framework?

-> Spring is a powerful open-source, loosely coupled (It means one object is not totally dependent on another object, It may get replaced), lightweight, java framework    
   meant for reducing the complexity of developing enterprise-level applications. 

-> One of the major feauters of Spring framework is dependency injection. It helps makes things simplier by allowing us to develop loosely coupled applications.
__________________________________________________________________________________________________________________________________________________________________________

What is Session and Session Factory in Hibernate ?

The Session Factory in Hibernate is responsible for creating of session objects. The Hibernate Session provides methods such as Update, Delete, Post, Get all, all the 

Crud based operations on database to which the session factory is connected.
__________________________________________________________________________________________________________________________________________________________________________

What is Hibernate first level and second level cache?

-> The main difference between session and session factory is :

the first level caching is only associated with session level and accessable only at the session level.

where as second level caching is associated with session factory and it is available to all the sessions.
________________________________________________________________________________________________________________________________________________________

What is the benefit of using Hibernate?

-> Some of the important advantages of Hibernate framework over JDBC are: 

-> Hibernate removes a lot of boiler-plate code that comes with JDBC API, the code looks more cleaner and readable.

-> Hibernate supports inheritance, associations and collections. These features are not present with JDBC API.
__________________________________________________________________________________________________________________________________________________________________________

Explain Flow of Spring MVC ?

Ans. The DispatcherServlet configured in web.xml file receives the request.

 The DispatcherServlet finds the appropriate Controller with the help of HandlerMapping and then invokes associated Controller.

Then the Controller executes the logic business logic and then returns ModelAndView object to the DispatcherServlet.

The DispatcherServlet determines the view from the ModelAndView object.

Then the DispatcherServlet passes the model object to the View.

The View is rendered and the Dispatcher Servlet sends the output to the Servlet container. Finally Servlet Container sends the result back to the user.
__________________________________________________________________________________________________________________________________________________________________________

What is Model and View Object ? 

-> The model job is to manage the data of the application. It recieves user input from the controller.

-> The view renders the presentation of the model in the particular format.
_________________________________________________________________________________________________________________________________________________________________________

-> Introduction to RESTful Web Services

REST stands for REpresentational State Transfer. It is developed by Roy Thomas Fielding, who also developed HTTP.
The main goal of RESTful web services is to make web services more effective.

-> It does not define the standard message exchange format. We can build REST services with both XML and JSON. 
   JSON is more popular format with REST. The key abstraction is a resource in REST. 
__________________________________________________________________________________________________________________________________________________________________________

Advantages of RESTful web services:

-> RESTful web services are platform-independent.

-> It can be written in any programming language and can be executed on any platform.

-> It provides different data format like JSON, text, HTML, and XML.

-> It is fast in comparison to SOAP because there is no strict specification like SOAP.

-> These are reusable.

-> They are language neutral.
__________________________________________________________________________________________________________________________________________________________________________

What is IOC (Inversion of Control) and how does it relate to the Spring framework?

-> IOC is a design principle in which the control of object creation and management is transferred to a container or framework. 

-> In the case of Spring, it manages the objects (beans) and their dependencies. Spring IOC allows you to decouple the dependencies between components and makes your code       more flexible and testable.
__________________________________________________________________________________________________________________________________________________________________________

Explain the concept of dependency injection in Spring IOC.


Dependency injection is a key aspect of Spring IOC. It is a process in which the dependencies of a class are provided externally rather than the class creating them itself.
__________________________________________________________________________________________________________________________________________________________________________

How does Spring handle bean initialization and destruction in IOC?

-> Spring provides different lifecycle methods to handle bean initialization and destruction. 

-> For initialization, you can use the @PostConstruct annotation on a method, or implement the InitializingBean interface and override the afterPropertiesSet() method. 

-> For destruction, you can use the @PreDestroy annotation on a method, or implement the DisposableBean interface and override the destroy() method.
__________________________________________________________________________________________________________________________________________________________________________

Can you explain the bean lifecycle in Spring IOC?

-> The bean lifecycle in Spring IOC consists of several phases: instantiation, population of properties, and initialization. 

-> After the initialization phase, the bean is ready to be used. 

-> When the application context is shut down, the destruction phase begins, and the bean's resources are released. The lifecycle is managed by the Spring container.
__________________________________________________________________________________________________________________________________________________________________________

What is the difference between singleton and prototype scope in Spring IOC?

-> In Spring, singleton scope (default) means that only one instance of a bean is created and shared throughout the application. 

-> Prototype scope, on the other hand, creates a new instance of the bean whenever requested. Singleton beans are created once and stored in the container, while   prototype beans are created each time they are requested.
__________________________________________________________________________________________________________________________________________________________________________

//@ManyToMany(mappedBy = "admins", cascade = CascadeType.ALL)
    @ManyToMany( cascade = CascadeType.ALL,fetch = FetchType.LAZY)
    @JoinTable(name = "property_admin", joinColumns = {
            @JoinColumn(name = "property_id") }, inverseJoinColumns = {
                    @JoinColumn(name = "admin_id") })
    
   //@Column(nullable = true)
    //@JsonIgnore
    @JsonBackReference
    private List<Property> properties;

what is cascade and fetch?

In the code snippet you provided, cascade and fetch are annotations used in the context of JPA (Java Persistence API) to define the behavior of a many-to-many relationship between two entities.

cascade = CascadeType.ALL: The cascade attribute specifies how operations (such as persist, merge, remove, etc.) should be cascaded from one entity to another. In this case, CascadeType.ALL means that all operations performed on the owning entity (the one where this annotation is defined) will be cascaded to the associated entities. So if an operation like persist or remove is performed on the owning entity, the same operation will be applied to the associated entities.

fetch = FetchType.LAZY: The fetch attribute determines how the associated entities should be loaded from the database. In this case, FetchType.LAZY indicates that the associated entities should be loaded lazily, meaning they will be fetched from the database only when explicitly accessed. This is useful when you have large collections of associated entities, and you want to avoid fetching them all at once, which could impact performance.

Regarding the other annotations in your code snippet:

@JoinTable: Specifies the details of the join table used to store the many-to-many relationship between the entities.
@JoinColumn: Specifies the column used for joining the owning entity with the associated entity in the join table.
@JsonBackReference (from Jackson library): Indicates that the annotated property should be ignored during JSON serialization to prevent circular references when serializing bidirectional relationships.
__________________________________________________________________________________________________________________________________________________________________________

What is an API-Gate way and why it is used ?

-> An API is an single point of entry to the clients of an application. It sits between the clients and collection of backend services for the application. 

-> It provides several important functions, some of the commonly used are :

1. Authentication and security policy entertainments.
2. Local balancing and circuit breaking.
3. Protocol translation and service discovery
4. Monitoring, logging, analytics and billing
5. Caching

Step 1: The client sends request to the API gate way.
Step 2: The API gateway validates the HTTP request.
Step 3: The API gateway checks the callers IP address and other HTTP headers against its allow-list and deny-list.
Step 4: The API gateway passses the request to the identity provider for authentication and authorisation.
Step 5: A higher level rate limit check is applied against the authenticated session. If it is over a limit the request is rejected at this point.
Step 6&7 : With the help of a service discovery component, the api gate way locates the appropriate backend service to handle the request by path matching.
Step 8: The API gateway transforms the request into the appropriate protocal and sends the transformed reuest to the backend service.
__________________________________________________________________________________________________________________________________________________________________________

What is Authentication and Authorisation in Spring Security ?

Authentication is the process of identifying and knowing the user that wants to access. 

Authorisation is the process to allow authority to perform actions in application.
__________________________________________________________________________________________________________________________________________________________________________

What is Eureka Server in Spring Boot ?

-> Eureka server is an application that holds all the information about the client-service applications.

-> Every Micro service registers in the eureka, so that eureka server knows all the client applications running on ports and its Ip address.
__________________________________________________________________________________________________________________________________________________________________________

SDLC (SOFTWARE DEVELOPMENTLIFE CYCLE)

1. Requirement Gathering
2. Analysis & 	Planning 
3. Design & Prototype (Blue print)
4. Development 
5. Testing 
6. Integration & Deployment 
7. Maintanence
__________________________________________________________________________________________________________________________________________________________________________

What is Rest template in microservices ?

Rest Template is a class responsible for mapping http requests and map the response for you. It is synchronous.
__________________________________________________________________________________________________________________________________________________________________________

What is Spring Security ?

-> Spring Security is a frame work that provides a strong ability for both authentication and authorisation

Feautures : 

-> support for authentication and authorisation
-> protection against attacks like clickjacking, session fixation, cross site request forgery
-> it provides integration of survlet with api
-> Optional integration with spring mvc
__________________________________________________________________________________________________________________________________________________________________________

What is criteria query ?

-> Criteria Query in hibernate is used for join queries for joining multiple tables, criteria queries are more flexible and provide better support to for writing dynamic queries as compared to HQL. 

-> useful methods for hibernate criteria join are createAlias(), setFetchMode(), and setProtection().
__________________________________________________________________________________________________________________________________________________________________________


What is pagenation ?

-> Pagenation is a process that is used to divide a large dataset into smaller chunks.
-> paging and sorting interfaces of a spring data provides methods for paging and sorting.

__________________________________________________________________________________________________________________________________________________________________________

Exception Handling - Spring Boot 

https://www.geeksforgeeks.org/spring-boot-exception-handling/
_________________________________________________________________________________________________________________________________________________________________________

what is @exceptionhandler annotation ?

-> it is a part of spring mvc module and is used with in the context of controller class

-> When an exception occurs during the execution of a request handling method in Spring MVC, 
   the @ExceptionHandler annotation allows you to define a method that will handle that specific type of exception. 

-> By annotating a method with @ExceptionHandler, you are essentially declaring it as an exception handler method for the associated controller class.

@Controller
public class MyController {

  @ExceptionHandler(Exception.class)
  public ModelAndView handleException(Exception ex) {
    // Handle the exception
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName("error");
    modelAndView.addObject("errorMessage", "An error occurred: " + ex.getMessage());
    return modelAndView;
  }

  // Other request handling methods...
}
__________________________________________________________________________________________________________________________________________________________________________

what is difference between controller and restcontroller ?

-> The main difference between Controller and RestController Annotation is ResponseBody Annotation.

->Controller annotation does not call @ResponseBody to all Controller's method itself. 

-> Whereas @RestController combines Controller and @ResponseBody, which use @ResponseBody to all its methods by default.
__________________________________________________________________________________________________________________________________________________________________________

what is Response Body ?

-> @ResponseBody. The @ResponseBody annotation tells a controller that the object returned is automatically serialized into JSON 
   and passed back into the HttpResponse object.
__________________________________________________________________________________________________________________________________________________________________________

what is Response Entity ?

-> ResponseEntity is a class provided by Spring Framework that represents an HTTP response. It allows you to customize the response status, headers, and body.


In the context of the save method:

java
Copy code
public ResponseEntity<Course> save(@RequestBody Course course) {
    service.save(course);
    return ResponseEntity.ok().body(course);
}



ResponseEntity<Course>: This is the return type of the method, indicating that the response will be wrapped in a ResponseEntity object containing a Course object as the response body.

ResponseEntity.ok(): This is a static factory method of the ResponseEntity class. It creates a new ResponseEntity with a response status of 200 OK. It indicates that the request was successful.

body(course): This method is called on the ResponseEntity object to set the response body as the provided course object.
__________________________________________________________________________________________________________________________________________________________________________

HIBERNATE MAPPINGS

ONE TO ONE MAPPINGS :

in one directional way :

public class customer {
	private int id;

	private string name;

	@onetoone(cascade = cascadetype.all)
	private Item item;
	
	// GETTERS AND SETTERS & constructor
}


public class Item{

	private int Id;
	private string name;
}

-------------------------
for bi-directional way :

public class customer {
	private int id;

	private string name;

	@onetoone(cascade = cascadetype.all)
	private Item item;
	
	// GETTERS AND SETTERS & constructor
}


public class Item{

	private int Id;
	private string name;
	
	@onetoone(cascade = cascadeType.all, mappedby = item)
	private Customer customer;

}

case 3 : what if u wanted to define joining table? 

public class customer {
	private int id;

	private string name;

	@onetoone(cascade = cascadetype.all)
	@Jointable(name = "customer_item",
			join columns = {@Join column(name = "customer_id)},
			inversejoincolumns = {@Joincolumn(name = "item_id)})
	private Item item;
	
	// GETTERS AND SETTERS & constructor
}

public class Item{

	private int Id;
	private string name;

}
__________________________________________________________________________________________________________________________________________________________________________

ONE TO MANY & MANY TO ONE :

case 1: 


public class customer {
	private int id;

	private string name;

	@onetomany(cascade = cascadetype.all)
	private List<Item> items = new ArrayList<>();
	
	// GETTERS AND SETTERS & constructor
}


public class Item{

	private int Id;
	private string name;

}

-> this will create 3 tables , customer & item & customer_items
---------------------

case 2 :


public class customer {
	private int id;

	private string name;

	@onetomany(cascade = cascadetype.all)
	@joincolumn(name = "customer_id")
	private List<Item> items = new ArrayList<>();
	
	// GETTERS AND SETTERS & constructor
}


public class Item{

	private int Id;
	private string name;

}

-> this will create 2 tables only customer & item.  in item u will have customer_id, this is one to many.
-------------------------


case 3 :

if you want to have many to one in bi-directional way also 


public class customer {
	private int id;

	private string name;

	@onetomany(cascade = cascadetype.all, mappedby="customer")
	private List<Item> items = new ArrayList<>();
	
	// GETTERS AND SETTERS & constructor
}


public class Item{

	private int Id;
	private string name;
	
	@Many2one(cascade = cascadetype.all)
	@JoinColumn(name="customer_id")
	private Customer customer;

}

-> u have to set items to customer and also have to set customer to items, this is how bidirectional works.
-> 2 tables will be shown, customer, item, in items u will have fk.
__________________________________________________________________________________________________________________________________________________________________________

MANY 2 MANY :

CASE 1:

public class customer {
	private int id;

	private string name;

	@manytomany(cascade = cascadetype.all)
	private Set<Item> items = new HashSet<>();
	
	// GETTERS AND SETTERS & constructor
}


public class Item{

	private int Id;
	private string name;
}

-> this will create 3 tables customer,item,customer_item
----------------------------

case 2 : BI-Directional


public class customer {
	private int id;

	private string name;

	@manytomany(cascade = cascadetype.all)
	@JoinTable(name = "customer_item,
		joincolumns={ @joincolumn(name = "customer_id")},
		inversejoincolumn = { @joincolumn = "item_id)})
	private Set<Item> items = new HashSet<>();
	
	// GETTERS AND SETTERS & constructor
}


public class Item{

	private int Id;
	private string name;
	
	@many2many(cascade = cascadetype.all, mappedby = "items")
	private Set<Customer> customer = new HashSet<>()
}
__________________________________________________________________________________________________________________________________________________________________________








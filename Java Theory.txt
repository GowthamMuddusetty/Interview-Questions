Why String is Immutable ?

string with the same content share the same storage in a string pool to minimize the copy of the same variable.
this is tosay, once a string is created, it cannot be changed, if any changes it it will lead to creation of new strings.

__________________________________________________________________________________________________________________________________________________________________________

 Exception Heriarchy ?

https://media.geeksforgeeks.org/wp-content/uploads/20220120111809/Group21-660x330.jpg

__________________________________________________________________________________________________________________________________________________________________________

What is Iterator?

A:) In Java, an iterator is an interface defined in the java.util package that provides a way to iterate over the elements of a collection in a sequential manner. 
hasNext(): returns true if there is at least one more element in the collection, otherwise false.
next(): returns the next element in the collection.
remove(): removes the last element returned by the iterator from the collection.
__________________________________________________________________________________________________________________________________________________________________________

Does set allows null and duplicate values?

A:) In Java, a Set is a collection that does not allow duplicate elements. That means that if you try to add an element to a Set that already exists in the Set, the new element will not be added.
HashSet and LinkedHashSet both allow null values.
TreeSet does not allow null values. If you try to add a null value to a TreeSet, it will throw a NullPointerException.
__________________________________________________________________________________________________________________________________________________________________________

What is Map in java?

A:)In Java, a Map is a collection that maps keys to values, where each key can only be associated with a single value. 
Map does not allow duplicate keys, but it does allow null values.

-> you can have a null value associated with a key in a Map, but you cannot have two keys with the same value. If you try to put a value into a Map using a key that already exists in the Map, the new value will replace the old value associated with that key.
__________________________________________________________________________________________________________________________________________________________________________

what is a survlet?

A:)  A servlet is a Java program that runs on a web server and handles client requests and responses over the HTTP protocol.
 Servlets are used to build web applications that can dynamically generate content and respond to user requests.

-> Servlets can handle various types of HTTP requests such as GET, POST, PUT, and DELETE
_________________________________________________________________________________________________________________________________________________________________________

Call BY Value?

A:)

Call by value means that the value of the argument is copied and passed to the method. 
This means that any changes made to the parameter within the method are not reflected outside of the method.
 

public class Example {
    public static void main(String[] args) {
        int x = 5;
        modifyValue(x);
        System.out.println(x); // Output: 5
    }

    public static void modifyValue(int value) {
        value = 10;
    }
}


Call by Reference?

A:)

Call by reference means that a reference to the memory location of the argument is passed to the method. 

public class Example {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        modifyArray(arr);
        System.out.println(Arrays.toString(arr)); // Output: [2, 4, 6]
    }

    public static void modifyArray(int[] array) {
        for (int i = 0; i < array.length; i++) {
            array[i] *= 2;
        }
    }
}
________________________________________________________________________________________________________________________________________________________________________

What are Cookies ?

A:) 
-> A cookie is a small piece of information that is persisted between the multiple client requests. 
   A cookie has a name, a single value, and optional attributes.
__________________________________________________________________________________________________________________________________________________________________________

What is Entry in Java?
 
A:)
->	Entry interface enables you to work with a map entry. The entrySet( ) method declared by the Map interface returns a Set containing the map entries. Each of these 	set elements is a Map. Entry object.
__________________________________________________________________________________________________________________________________________________________________________

What is RowSet ?

A:) 

Rowset Interface is basically an extension of JDBC ResultSet and is part of the java.sql.package
There are 2 types of RowSet Connected and Dis-Connected.

-> Connected Rowset are those which establish connection and retain until the apllication termiantes.

-> DisConnected rowset perfoms or establishes a connection, executues a query such as retreiveing data from the database and closes the connection.

-> According to the implementation of rowset there are 5 types of implemenatations

 1. JdbcRowset 
 2. Cached Rowset
 3. WebRowset 
 4. Filetered rowset 
 5. Join Rowset
__________________________________________________________________________________________________________________________________________________________________________

What is Servlet ?

A:) 
-> A servlet is generally a java-based programme that runs on web server and process client requests and generates dynamic web pages,process and respond to
HTTP requests.

-> When a client sends a HTTP request to the server, the servelet container recieves the request and pass it to appropriate servlet. 
-> The servelt then process the request and sends the http response back to the client.

__________________________________________________________________________________________________________________________________________________________________________

How many types of servlets ?

A:) 

-> There are basically 2 types of servelets. HTTP & Generic Type servelets. we can use Constructor to intialise servelet with the help of init() method and 
descructor method to remove the servelet from the resources using destroy().

-> There are basically two types of servelts based on the interface they implement.
Generic Survlet : It is a abstract class that implements the Servlet, Servlet-Config. It provides a generic implementation of the servlet interface.

HTTP Servlet : It is a abstract class that extends Generic servlet and provides Http specific functionality. 
It implements doGet(), doPost(), doPut(), doDelete() and other methods to handle HTTP requests and responses.

-> Both servlets are used to process client  requsts and generate dynamic responses. 

-> HTTP servlets are most commonly used in creating web applications that work with http requests and responses.

-> While Generic servets are more commonly used in creating custom survlets that work with other protocals and data formats.

__________________________________________________________________________________________________________________________________________________________________________

What are the 3 main methods of a servlet class?

-> The init, service and destroy are the life cycle methods of servlet.
_________________________________________________________________________________________________________________________________________________________________________

-> In method overloading the return type doesnt matters. what matters is only the type of parameters and the no of parameters.

-> ServletConfig is used for sharing init parameters specific to a servlet while ServletContext is for sharing init parameters within any Servlet within a web
   application.
__________________________________________________________________________________________________________________________________________________________________________

Difference between Execute and ExecuteUpdate and ExecuteQuery ?

Execute() : This method is used for all types of Sql Statements and it returns a boolean value of TRUE or FALSE. If the method returns "True" it returns a ResultSet object. If False it returns int value.

ExecuteUpdate(): This method is used for execution of DML Statements(Insert,  Update, Delete) which is return int value, that is count of rows affected.

ExecuteQuery(): This method is used for retreiving data from database and this method returns ResultSet Object and that returns the data according to the query.
__________________________________________________________________________________________________________________________________________________________________________

 What are the life-cycle methods for a servlet?

public void init(ServletConfig config)  :  It is invoked only once when first request comes for the servlet. It is used to initialize the servlet.

public void service(ServletRequest request,ServletResponse)throws ServletException,IOException : It is invoked at each request.The service() method is used to service the request.

public void destroy() : It is invoked only once when servlet is unloaded.
__________________________________________________________________________________________________________________________________________________________________________

 Who is responsible to create the object of servlet?

The web container or servlet container.
__________________________________________________________________________________________________________________________________________________________________________

 What is difference between Get and Post method?

1) Limited amount of data can be sent because data is sent in header.     1> Large amount of data can be sent because data is sent in body.

2) Not Secured because data is exposed in URL bar.                        2> Secured because data is not exposed in URL bar.

3> Can be bookmarked                                                      3> Cannot be bookmarked.

4>  Idempotent                                                            4> Non-idempotent
__________________________________________________________________________________________________________________________________________________________________________

What is ConcurrentHashMap used for?

ConcurrentHashMap is the Map implementation that allows us to modify the Map while iteration. 
The ConcurrentHashMap operations are thread-safe. ConcurrentHashMap doesn't allow null for keys and values.
__________________________________________________________________________________________________________________________________________________________________________

What are new features introduced with Java 8 ?

Ans. Lambda Expressions , Interface Default and Static Methods , Method Reference , Parameters Name , Optional , Streams, Concurrency.
__________________________________________________________________________________________________________________________________________________________________________

What is flow of servlets ? 

-> First the server checks if the servlet is requested for the first time.

-> if 	Yes, web container does the following task:

-> Loads the servlet class
../
-> Instantiates the servlet class

-> Calls the init method passing the servlet config object.

-> else calls the service method passing request and response object.

-> The web container calls the destroy method when it needs to remove the servlet such as at time of stopping server or undeploying the project.
__________________________________________________________________________________________________________________________________________________________________________

Difference between ConcurrentHashMap, Hashtable and Synchronized Map in Java

-> The difference between Hashtable and ConcurrentHashMap, both can be used in the multithreaded environment,
   but once the size of Hashtable becomes considerable large performance degrade because for iteration it has to be locked for a longer duration.

-> Since ConcurrentHashMap introduced the concept of segmentation, how large it becomes only certain part of it get locked to provide thread safety 
   so many other readers can still access map without waiting for iteration to complete. 

-> In Summary, ConcurrentHashMap only locked certain portion of Map while Hashtable locks full map while doing iteration.
__________________________________________________________________________________________________________________________________________________________________________

explain about 4 types of Functional Interfaces in java 8?

->  In Java 8, a functional interface is an interface that has only one abstract method. This concept is important in the context of lambda expressions, which are a new                    language feature introduced in Java 8 for writing concise and expressive code.

Here are the four types of functional interfaces in Java 8:

Consumer: The Consumer interface represents an operation that takes a single argument and returns no result. Its functional method is called accept().

Supplier: The Supplier interface represents an operation that takes no arguments and returns a value. Its functional method is called get().

Predicate: The Predicate interface represents a boolean-valued function of one argument. Its functional method is called test().

Function: The Function interface represents a function that takes one argument and returns a value. Its functional method is called apply().
__________________________________________________________________________________________________________________________________________________________________________

What is Stream?

-> Stream represents a sequence of objects from a source, which supports aggregate operations. 
__________________________________________________________________________________________________________________________________________________________________________

What are JDBC steps ? 

-> import ---> java.sql

-> Register and load driver.

-> Create connection 

-> Create Statement 

-> Execute Query 

-> process the results 

-> close.
__________________________________________________________________________________________________________________________________________________________________________

How Java provide high Performance ?

Ans. Java uses Just-In-Time compiler to enable high performance. 

Just-In-Time compiler is a program that turns Java bytecode into instructions that can be sent directly to the processor.
__________________________________________________________________________________________________________________________________________________________________________

How to implement an immutable class ?

Ans. We can make a class immutable by

1. Making all methods and variables as private.

2. Setting variables within constructor.

Public Class ImmutableClass{
     private int member;
     ImmutableClass(int var){
         member=var;
     } 
} 

and then we can initialize the object of the class as

ImmutableClass immutableObject = new ImmutableClass(5);

Now all members being private , you can't change the state of the object. 
__________________________________________________________________________________________________________________________________________________________________________

What is meant by constructor chaining?

-> Constructor chaining is the process of calling a sequence of constructors. 

-> We can do it in two ways: by using this() keyword for chaining constructors in the same class.

-> by using super() keyword for chaining constructors from the parent class.
__________________________________________________________________________________________________________________________________________________________________________

What is Enumeration ? 

-> An enumeration (enum for short) in Java is a special data type which contains a set of predefined constants.
__________________________________________________________________________________________________________________________________________________________________________

what is PreparedStatement and Statement in jdbc?

->  In JDBC, both Statement and PreparedStatement are interfaces used to execute SQL queries against a database. 
    However, they have some differences in their functionality and usage.

-> Statement is a basic interface in JDBC that is used to execute 

-> Statement is an interface in JDBC that is used to execute a static SQL statement and return the results. 
   Static SQL statements are those whose values are hard-coded at the time of execution.

-> PreparedStatement is used for dynamic SQL statements with parameters, while Statement is used for static SQL statements.

-> PreparedStatement provides protection against SQL injection attacks, while Statement does not.
__________________________________________________________________________________________________________________________________________________________________________

What is the difference between Iterator and ListIterator?

-> Iterator traverses the elements in the forward direction only whereas ListIterator traverses the elements into forward and backward direction.
__________________________________________________________________________________________________________________________________________________________________________

What is the difference between List and Set?

-> The List and Set both extend the collection interface. However, there are some differences between the both which are listed below.

-> The List can contain duplicate elements whereas Set includes unique items.

-> The List is an ordered collection which maintains the insertion order whereas Set is an unordered collection which does not preserve the insertion order.

-> The List interface contains a single legacy class which is Vector class whereas Set interface does not have any legacy class.

-> The List interface can allow n number of null values whereas Set interface only allows a single null value.
__________________________________________________________________________________________________________________________________________________________________________

What is the difference between HashSet and TreeSet?

-> The HashSet and TreeSet, both classes, implement Set interface. The differences between the both are listed below.

-> HashSet maintains no order whereas TreeSet maintains ascending order.

-> HashSet impended by hash table whereas TreeSet implemented by a Tree structure.

-> HashSet performs faster than TreeSet.

-> HashSet is backed by HashMap whereas TreeSet is backed by TreeMap.
__________________________________________________________________________________________________________________________________________________________________________

What is the difference between Set and Map?

-> The differences between the Set and Map are given below.

-> Set contains values only whereas Map contains key and values both.

-> Set contains unique values whereas Map can contain unique Keys with duplicate values.

-> Set holds a single number of null value whereas Map can include a single null key with n number of null values.
__________________________________________________________________________________________________________________________________________________________________________

What is the difference between HashSet and HashMap?

-> The differences between the HashSet and HashMap are listed below.

-> HashSet contains only values whereas HashMap includes the entry (key, value). HashSet can be iterated, but HashMap needs to convert into Set to be iterated.

-> HashSet implements Set interface whereas HashMap implements the Map interface

-> HashSet cannot have any duplicate value whereas HashMap can contain duplicate values with unique keys.

-> HashSet contains the only single number of null value whereas HashMap can hold a single null key with n number of null values.
__________________________________________________________________________________________________________________________________________________________________________

What is the difference between HashMap and TreeMap?

-> The differences between the HashMap and TreeMap are given below.

-> HashMap maintains no order, but TreeMap maintains ascending order.

-> HashMap is implemented by hash table whereas TreeMap is implemented by a Tree structure.

-> HashMap can be sorted by Key or value whereas TreeMap can be sorted by Key.

-> HashMap may contain a null key with multiple null values whereas TreeMap cannot hold a null key but can have multiple null values.
__________________________________________________________________________________________________________________________________________________________________________

What is the difference between Collection and Collections?

-> The differences between the Collection and Collections are given below.

-> The Collection is an interface whereas Collections is a class.

-> The Collection interface provides the standard functionality of data structure to List, Set, and Queue.

->  However, Collections class is to sort and synchronize the collection elements.

-> The Collection interface provides the methods that can be used for data structure
   whereas Collections class provides the static methods which can be used for various operation on a collection.
__________________________________________________________________________________________________________________________________________________________________________

 What is the difference between Comparable and Comparator?

-> Comparable provides only one sort of sequence.	                        -> The Comparator provides multiple sorts of sequences.

-> It provides one method named compareTo().	                               -> It provides one method named compare().

-> If we implement the Comparable interface, The actual class is modified.   -> The actual class is not changed.
__________________________________________________________________________________________________________________________________________________________________________

What is Servlet Context and Servlet Config ?

A)  -> ServletConfig is used for sharing init parameters specific to a servlet.

    -> Where as ServletContext is for sharing init parameters within any servlet with in a web application.
__________________________________________________________________________________________________________________________________________________________________________

Data Types and size of DT ?

A) 

-> Byte  - 1(byte)

-> Short - 2 bytes

-> Int  -  4 bytes 

-> Long  -  8 bytes

-> Float  - 4 bytes 

-> Double  - 8 bytes

-> Char  -  2 bytes

-> Boolean  - 1 bit
__________________________________________________________________________________________________________________________________________________________________________

Threads in java ?

-> In java, a thread is a unit of execution that allows a programme to perform multiple tasks concurrently.

-> Java provides a buiult-in support for multi-threading the the "java.lang.Thread" class.

-> A thread is created by instantiating an object of the "Thread" class and calling its method start().

-> when the start() method is called, a new thread is created and its run() method is invoked in separated flow of execution.

-> Multithreading is commonly used in Java for tasks that require parallel processing,
   such as running multiple background tasks, performing I/O operations, and handling user interface events. 



// Way 1
// Creating thread By Extending To Thread class

class MyThread extends Thread {

	// Method 1
	// Run() method for our thread
	public void run()
	{

		// Print statement
		System.out.println(
			"Thread is running created by extending to parent Thread class");
	}

	// Method 2
	// Main driver method
	public static void main(String[] args)
	{

		// Creating object of our thread class inside main()
		// method
		MyThread myThread = new MyThread();
	
		// Starting the thread
		myThread.start();
	}
}

_________________________________________________________________________________________________________________________________________________________________________

What is thread safe in java ?

Thread safety in java is the process to make our program safe to use in multithreaded environmentthere are different ways through which we can make our program thread safe. Synchronization is the easiest and most widely used tool for thread safety in java.
__________________________________________________________________________________________________________________________________________________________________________

what is aggregation and composition in java ?

A) 
-> Aggregation and composition are two important concepts in object-oriented programming (OOP) that describe the relationship between two classes.

Aggregation:
 
-> Aggregation is a relationship between two classes where one class contains a reference to another class as a member variable.

-> An example of aggregation is a university containing multiple departments, where each department can exist independently of the university.

Composition:

-> Composition is a relationship between two classes where one class contains another class as a member variable, 
   and the contained class cannot exist independently of the containing class.

-> When the containing class is destroyed, the contained class is also destroyed.
   An example of composition is a car containing an engine, where the engine cannot exist without the car.
__________________________________________________________________________________________________________________________________________________________________________ 

What is the difference between == and .equals() for comparing objects in Java?

-> The == operator compares object references, checking if they refer to the same memory location.

-> The .equals() method compares the actual content of the objects (the values they hold) based on the implementation of the method in the object's class.

-> In other words, == checks for reference equality, while .equals() checks for value equality.
__________________________________________________________________________________________________________________________________________________________________________

What is the difference between final, finally, and finalize in Java?

-> final is a keyword used to make a variable, method, or class constant and unchangeable.

-> finally is a block that follows a try-catch block and is used to ensure that a section of code is always executed, regardless of whether an exception occurs or not.

-> finalize is a method called by the garbage collector before reclaiming the memory occupied by an object. However, it's generally recommended to use the try-with-
   resources statement or explicitly close resources instead of relying on finalize
__________________________________________________________________________________________________________________________________________________________________________

when finally block wont be executed ?

In Java, there is one possibility where finally block will not be executed. They are as follows:

1. When the System.exit() method is called in the try block before the execution of finally block, finally block will not be executed.


package finallyProgram;
public class FinallyBlock1
{
 void m1()
 { 
    try {
       System.out.println("I am in try block");
       System.exit(0);
    }
    finally {
       System.out.println("I am in finally block");	
    }
   System.out.println("Statement after finally block");
  }
public static void main(String[] args) 
{
   FinallyBlock1 obj = new FinallyBlock1();
   obj.m1();
  }
}


Output:
       I am in try block
---------------
Program code 2:

package finallyProgram;
public class FinallyBlock2 {
void m1()
{ 
  int a = 20, b = 0;	
  try {
     System.out.println("I am in try block");
     System.exit(0);
     int c = a/b;
     System.out.println("Result: " +c);
  }
  catch(ArithmeticException ae)
  {
     System.out.println("I am in catch block");
  }
  finally {
      System.out.println("I am in finally block");	
  }
 System.out.println("Statement after finally block");
}
public static void main(String[] args) 
{
   FinallyBlock2 obj = new FinallyBlock2();
   obj.m1();
  }
}
Output:
      I am in try block
---------------
Program code 3:

package finallyProgram;
public class FinallyBlock3 {
void m1()
{ 
  int a = 20, b = 0;	
  try {
     System.out.println("I am in try block");
     int c = a/b;
     System.exit(0);
     System.out.println("Result: " +c);
  }
  catch(ArithmeticException ae)
  {
    System.out.println("I am in catch block");
  }
  finally 
  {
    System.out.println("I am in finally block");	
  }
  System.out.println("Statement after finally block");
}
 public static void main(String[] args) 
 {
 FinallyBlock3 obj = new FinallyBlock3();
  obj.m1();
  }
}
Output:
       I am in try block
       I am in catch block
       I am in finally block
       Statement after finally block
__________________________________________________________________________________________________________________________________________________________________________

what is try with resources in java ?

-> The try-with-resources statement is a try statement that declares one or more resources. 

-> A resource is an object that must be closed after the program is finished with it. 
 
-> The try-with-resources statement ensures that each resource is closed at the end of the statement

static String readFirstLineFromFile(String path) throws IOException {
	    try (FileReader fr = new FileReader(path);
	         BufferedReader br = new BufferedReader(fr)) {
	        return br.readLine();
	    }
	}

Here are some examples of commonly used resources that need to be closed after use:

File streams: When reading from or writing to files.
Database connections: When interacting with databases.
Network sockets: When establishing connections to remote servers.
Input/output streams: When performing input/output operations, such as reading or writing data.
Readers and writers: Used for reading and writing character data.
JDBC resources: PreparedStatements, ResultSets, and other JDBC-related objects.
Image resources: When working with images, such as loading and manipulating them.
Audio resources: When playing or manipulating audio files.
ZIP file streams: When reading from or writing to ZIP archives.
BufferedReader and BufferedWriter: Used for efficient reading and writing of character data.
__________________________________________________________________________________________________________________________________________________________________________
 
Buffer Reader and Buffer Writer ?

buffer reader:

-> A BufferedReader reads text from a character stream with buffering capabilities, which helps in reducing the number of I/O operations. 

-> It provides methods like readLine() to read a line of text, read() to read a single character, and more.

try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        // Process each line of text
        System.out.println(line);
    }
} catch (IOException e) {
    // Exception handling
}


buffer writer :

-> A BufferedWriter writes text to a character stream with buffering capabilities. 

-> Similar to BufferedReader, it writes data to an internal buffer and performs fewer I/O operations, which can improve performance. 

-> It provides methods like write(String) to write a string, newLine() to write a platform-specific line separator, and more.

try (BufferedWriter writer = new BufferedWriter(new FileWriter("file.txt"))) {
    writer.write("Hello, world!");
    writer.newLine();
    writer.write("This is a new line.");
} catch (IOException e) {
    // Exception handling
}
__________________________________________________________________________________________________________________________________________________________________________

What is the difference between String, StringBuilder, and StringBuffer in Java?

-> String is immutable, meaning its value cannot be changed once created. Each time you modify a String, a new object is created in memory.

-> StringBuilder and StringBuffer are mutable classes used to manipulate strings. They provide methods to append, delete, or modify strings. StringBuilder is not 
   thread-safe, while StringBuffer is thread-safe.

-> If you need a mutable string and don't require thread safety, use StringBuilder. If you need thread safety, use StringBuffer.
__________________________________________________________________________________________________________________________________________________________________________

What are checked and unchecked exceptions in Java?

-> Checked exceptions are exceptions that need to be declared in the method signature using the throws keyword or handled using a try-catch block. 
   Examples include    IOException, SQLException,ClassNotFoundException, SocketException, FileNotFoundException etc.

-> Unchecked exceptions, also known as runtime exceptions, do not need to be declared or caught explicitly. They are subclasses of RuntimeException or Error. 
   Examples   include NullPointerException, ArrayIndexOutOfBoundsException, etc.
_________________________________________________________________________________________________________________________________________________________________________

What is the difference between ArrayList and LinkedList?

-> ArrayList is implemented as a resizable array and provides fast random access but slower insertion and deletion of elements in the middle of the list.

-> LinkedList is implemented as a doubly-linked list and provides fast insertion and deletion of elements but slower random access.

-> Use ArrayList when you need fast access to elements and LinkedList when you frequently need to add or remove elements from the list.
__________________________________________________________________________________________________________________________________________________________________________

What is the difference between throw and throws in Java?

-> The throw keyword is used to explicitly throw an exception in a method or block of code.

-> The throws keyword is used in the method signature to indicate that the method may throw one or more exceptions and that the caller of the method needs to handle or       propagate those exceptions.
__________________________________________________________________________________________________________________________________________________________________________

Explain the transient keyword in Java.

The transient keyword is used to indicate that a variable should not be serialized when an object is converted to a byte stream (e.g., for storage or network transmission) using Java's Serialization API.
_________________________________________________________________________________________________________________________________________________________________________

What is the purpose of the static keyword in Java?

The static keyword is used to define a class-level member that belongs to the class itself rather than to an instance of the class.
__________________________________________________________________________________________________________________________________________________________________________

what are intermediate and terminal operations in java 8?

-> In Java 8 and later versions, the Stream API introduced two types of operations: 
   intermediate operations and terminal operations. These operations are used to perform various transformations and computations on a stream of elements.

-> Intermediate Operations:

Intermediate operations are operations that are applied to a stream and produce a new stream as a result. They are lazy, meaning they do not execute immediately. 
Instead, they are stored and executed only when a terminal operation is called.

Some common intermediate operations in Java 8 include:

filter(Predicate<T> predicate): Returns a stream consisting of the elements that match the given predicate.
map(Function<T, R> mapper): Applies the given function to each element of the stream and returns a stream of the results.
distinct(): Returns a stream with distinct elements (removes duplicates).
sorted(): Returns a stream with sorted elements based on their natural order.
limit(long maxSize): Returns a stream truncated to the specified size.
Intermediate operations allow you to chain multiple operations together to form a pipeline.

Terminal Operations:

Terminal operations are operations that are applied to a stream and produce a non-stream result, such as a value, a collection, or a side effect. When a terminal operation is called, all the previous intermediate operations are executed.

Some common terminal operations in Java 8 include:

forEach(Consumer<T> action): Performs an action for each element in the stream.
collect(Collector<T, A, R> collector): Collects the elements of the stream into a collection or a single value.
count(): Returns the count of elements in the stream.
anyMatch(Predicate<T> predicate): Returns true if any elements of the stream match the given predicate.
allMatch(Predicate<T> predicate): Returns true if all elements of the stream match the given predicate.
findFirst(): Returns the first element of the stream.
__________________________________________________________________________________________________________________________________________________________________________

what are parallel streams in java8?

import java.util.Arrays;
import java.util.List;

public class ParallelStreamExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Sequential stream
        int sumSequential = numbers.stream()
                .filter(n -> n % 2 == 0)
                .mapToInt(n -> n)
                .sum();

        // Parallel stream
        int sumParallel = numbers.parallelStream() 
                .filter(n -> n % 2 == 0)
                .mapToInt(n -> n)
                .sum();

        System.out.println("Sum (Sequential): " + sumSequential);
        System.out.println("Sum (Parallel): " + sumParallel);
    }
}


-> In the example above, we have a list of numbers, and we want to find the sum of the even numbers. The first part demonstrates the sequential stream, 
   where operations are executed sequentially on a single thread.
 
-> The second part shows the parallel stream, where operations are divided among multiple threads for concurrent execution.

-> By using parallel streams, Java automatically distributes the workload across available threads and combines the results at the end. 
   This can significantly improve the   performance of computationally intensive or data-intensive operations when working with large datasets

-> However, it's important to note that not all operations are suitable for parallel execution. Some operations, like forEach, rely on the order of elements and may  
   produce incorrect results when executed in parallel.
__________________________________________________________________________________________________________________________________________________________________________

What is an interface in Java?

Ans: An interface in Java is a mechanism that is used to achieve complete abstraction. 

->  It is basically a kind of class that contains only constants and abstract methods.
__________________________________________________________________________________________________________________________________________________________________________

Can we define private and protected modifiers for data members (fields) in interfaces?

Ans: No, we cannot define private and protected modifiers for variables in interface because the fields (data members) declared in an interface are by default public,     
    static, and final.
__________________________________________________________________________________________________________________________________________________________________________

How HashMap internally works?

-> A hashmap uses a hashtable, however it internally implemented by 2 data structutres namely arrays and linked list. 

-> When ever you declare a hashmap, internally it will create an array of buckets. The buckets are reffered to as nodes or you can say as list.
__________________________________________________________________________________________________________________________________________________________________________

Collections heirarchy ?

https://data-flair.training/blogs/wp-content/uploads/sites/2/2018/03/hierarchy-of-collection-framework-in-java.webp
__________________________________________________________________________________________________________________________________________________________________________

what is   lock ?

dead lock in java is a situation that occur when thread is waiting for an object lock, that is acquired by another thread and second thread is waiting for an object lock that is acquired by th first thread, since both the threads are waiting for each other to release the lock simultaneously this condition is called dead lock.
__________________________________________________________________________________________________________________________________________________________________________

Difference between Abstraction and Encapsulation ? 

-> Abstraction is the method of hiding the unwanted information.
-> Whereas encapsulation is a method to hide the data in a single entity or unit along with a method to protect information from outside. 
-> We can implement abstraction using abstract class and interfaces.
__________________________________________________________________________________________________________________________________________________________________________

object class methods ?

-> Object() - constructor 
1. getClass()
2. finalize(), its deprcated since 9  
3. notify()
4. notifyAll()
5. clone()
6. wait() --> overloaded 3 methods 
7. toString()
8. equals()
9. hashcode()
__________________________________________________________________________________________________________________________________________________________________________


SOLID PRINCIPLES 

S -> Single Responsibility Principle
O -> Open & Close principle
L -> Leskov's Substitution principle
I -> Interface Segregation principle
D -> Dependency Inversion Principle

Solid principles are the design principles  that enable us to manage most of the software problems.

Single Responsibility Principle (SRP) :
-> the srp states that every java class must perform a single functionality. 
-> Implementation of multiple functionalities in a single class mashup the code.

Open closed principle (OCP) : 
-> the opc states that according to new requirements the module should be open for extension but closed for modification. 

Liskov Substitution Prinicipal (LSP) : 
-> It applies to inheritance in such a way that the derived classes must be completely substitutable for their base classes. 
-> In other words, if class A is sub type of class B, then we should be able to replace B with A without interupting the behaviour of programme.

Interface Segregation Principal (ISP) :
-> Clients should not be forced to depend on interfaces they do not use. 
-> This principle promotes the idea of creating specific, focused interfaces rather than large, monolithic interfaces.
-> It aims to avoid "fat" interfaces with unnecessary methods and reduces the coupling between clients and implementations.

Dependency Inversion Principle (DIP): 
-> High-level modules should not depend on low-level modules. Both should depend on abstractions. 
-> This principle encourages the use of dependency injection and inversion of control to decouple modules and reduce direct dependencies. 
-> It promotes the use of interfaces and abstract classes to define contracts and allow for flexibility and easier testing.
_______________________________________________________________________________________________________________________________________________________________________


Shallow copy vs Deep Copy ?

SHALLOW COPY :


A shallow copy creates a new object and copies the reference of the original object into it. It means that both the original object and the copied object will point to the same memory location. Any changes made to the original object will be reflected in the copied object and vice versa. In other words, a shallow copy creates a new object but shares the internal references with the original object.

To perform a shallow copy in Java, you can use the clone() method or copy constructors. However, it's important to note that for the clone() method to work properly, the class must implement the Cloneable interface.

Here's an example of a shallow copy using the clone() method:


class MyClass implements Cloneable {
    private int value;

    public MyClass(int value) {
        this.value = value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass original = new MyClass(10);

        try {
            MyClass shallowCopy = (MyClass) original.clone();

            System.out.println(original.getValue());     // Output: 10
            System.out.println(shallowCopy.getValue());  // Output: 10

            original.setValue(20);

            System.out.println(original.getValue());     // Output: 20
            System.out.println(shallowCopy.getValue());  // Output: 20 (both values changed)
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
}


Deep Copy:

A deep copy creates a new object and recursively copies all the fields of the original object into the new object. It means that even if the original object changes, the copied object remains unaffected. In other words, a deep copy creates a new object and copies all the internal references, recursively, so that both objects are completely independent.


class MyClass implements Cloneable {
    private int value;

    public MyClass(int value) {
        this.value = value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        MyClass cloned = (MyClass) super.clone();
        // Perform deep copy for any mutable fields
        // In this case, there are no mutable fields, so no further action is needed
        return cloned;
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass original = new MyClass(10);

        try {
            MyClass deepCopy = (MyClass) original.clone();

            System.out.println(original.getValue());  // Output: 10
            System.out.println(deepCopy.getValue());  // Output: 10

            original.setValue(20);

            System.out.println(original.getValue());  // Output: 20
            System.out.println(deepCopy.getValue());  // Output: 10 (deep copy remains unchanged)
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
}
__________________________________________________________________________________________________________________________________________________________________________

Why do we use Design Patterns ?

-> Design patterns are a set of proven solutions to common software design problems. 

-> They provide standardized approaches for designing software systems that are reusable, maintainable, and scalable. 

-> Java, being an object-oriented programming language, is well-suited for implementing design patterns.
__________________________________________________________________________________________________________________________________________________________________________

Design Patterns in java ?


Certainly! There are several design patterns commonly used in Java. Here are some of the most well-known design patterns in Java:

Creational Patterns:

-> Singleton: Ensures that a class has only one instance and provides a global point of access to it.

-> Factory Method: Defines an interface for creating objects, but lets subclasses decide which class to instantiate.

-> Abstract Factory: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

-> Builder: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.

-> Prototype: Creates new objects by cloning existing ones, avoiding the need for complex initialization.


Structural Patterns:

-> Adapter: Allows objects with incompatible interfaces to work together by converting the interface of one class into another.

-> Decorator: Dynamically adds new behaviors to an object without changing its existing code.

-> Composite: Represents a group of objects as a single object, treating individual and composite objects uniformly.

-> Proxy: Provides a surrogate or placeholder for another object to control access to it.

-> Facade: Provides a simplified interface to a complex subsystem, making it easier to use.


Behavioral Patterns:

-> Observer: Defines a one-to-many dependency between objects, so that when one object changes state, all its dependents are notified and updated automatically.

-> Strategy: Encapsulates a family of algorithms and makes them interchangeable, allowing clients to switch between algorithms at runtime.

-> Command: Encapsulates a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.

-> Template Method: Defines the skeleton of an algorithm in a base class, allowing subclasses to provide specific implementations of certain steps.

-> Iterator: Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.
__________________________________________________________________________________________________________________________________________________________________________







